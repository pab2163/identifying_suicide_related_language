---
title: "Aggregate Stage 1 Codings"
author: "Paul Alexander Bloom"
date: "2025-04-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script aggregates human labels of the presence vs absence of suicide-related language

```{r}
library(tidyverse)
library(purrr)

combine_coder_files = function(file_paths, unique_col_name) {
  
  data_list = map(file_paths, function(path) {
    df = read_csv(path, show_col_types = FALSE)
    
    coder_name = tools::file_path_sans_ext(basename(path))
    
    if (!(unique_col_name %in% names(df))) {
      stop(glue::glue("Column `{unique_col_name}` not found in {path}"))
    }
    
    df = df %>% rename(!!coder_name := all_of(unique_col_name))
    
    df
  })

  # Determine shared columns (i.e., everything except the renamed unique columns)
  join_keys = reduce(data_list, function(x, y) intersect(names(x), names(y)))
  
  combined_df = reduce(data_list, full_join, by = join_keys)
  
  return(combined_df)
}




coalesce_coder_columns = function(combined_df, coder_key_path) {
  
  # Read in the coder key: subjectID, coder1, coder2
  coder_key = read_csv(coder_key_path, show_col_types = FALSE)

  # Pivot longer to get tidy format: one row per subjectID per coder
  long_df = combined_df %>%
    pivot_longer(
      cols = contains('step_one_coded'),
      names_to = "coder",
      values_to = "code"
    ) %>%
    mutate(coder = gsub('step_one_coded_', '', coder))

  # Join twice: once for coder1, once for coder2
  df_coder1 = coder_key %>%
    select(subjectID, coder=coder1) %>%
    left_join(long_df, by = c("subjectID", "coder")) %>%
    rename(code1 = code, coder1_name = coder)

  df_coder2 = coder_key %>%
    select(subjectID, coder=coder2) %>%
    left_join(long_df, by = c("subjectID", "coder")) %>%
    rename(code2 = code, coder2_name = coder)

  # Join them back together by subjectID
  final_df = df_coder1 %>%
    left_join(df_coder2,
      by = c('subjectID', 'tm_message_start','tm_message_end', 
             'timeDiff', 'id_app', 'text_clean')
    )
  
  check = final_df %>%
    group_by(subjectID, coder1_name, coder2_name) %>%
    count()
  
  print(check)
  
  final_df = final_df %>%
    select(-code1, -code2, -coder1_name, -coder2_name, everything(), code1, code2, coder1_name, coder2_name)


  return(final_df)
}
```


```{r}
# Step 1: Combine the coder files
file_paths = list.files("/Volumes/AUERBACHLAB/Columbia/MAPS_Language/data/manual_coding/suicide_language/step_one_coding/coded_reconverted_csvs/", 
                        pattern = "\\.csv$", full.names = TRUE)

combined_data = combine_coder_files(file_paths, unique_col_name = "suicide_related")

# Step 2: Coalesce using key file
coalesced = coalesce_coder_columns(combined_data, coder_key_path = "../coding manuals/step_1_coding_delegation.csv")
coalesced = coalesced %>%
  mutate(
    code1 = replace_na(code1, 0),
    code2 = replace_na(code2, 0)
  )

agreement_check =  coalesced%>%
  group_by(subjectID, coder1_name, coder2_name) %>%
  summarise(n=n(), 
            coder1_positive = sum(code1==1),
            coder2_positive = sum(code2==1),
            agreed_positive = sum(code1==1 & code2 ==1),
            agreed = sum(code1==code2),
            disagreed = sum(code1!=code2),
            agree_prop = agreed/n)

disagree_rows = dplyr::filter(coalesced, code1 != code2)


agree_rows = dplyr::filter(coalesced, code1 == code2, code1==1)


kappa_by_subject = coalesced %>%
  select(subjectID, code1, code2) %>%
  group_by(subjectID) %>%
  group_map(~ {
    df = .x %>% select(code1, code2) %>% drop_na()
    if (nrow(df) == 0) {
      tibble(subjectID = .y$subjectID, kappa = NA_real_)
    } else {
      kappa_val = psych::cohen.kappa(as.matrix(df))$kappa
      tibble(subjectID = .y$subjectID, kappa = kappa_val)
    }
  }) %>%
  bind_rows()

```


# Overall Kappa

```{r}
data_for_kappa = coalesced %>% dplyr::select(code1, code2) %>% ungroup() 
kappa_mat = as.matrix(data_for_kappa)
psych::cohen.kappa(x=kappa_mat)


# percent agreement
100*sum(coalesced$code1==coalesced$code2) / nrow(coalesced)
```


# Save out rows of disagreement for 3rd coder
```{r}
disagree_rows_for_coder3 = disagree_rows %>% 
  dplyr::select(subjectID, tm_message_start, tm_message_end, 
                timeDiff, id_app, text_clean)

disagree_rows_for_coder3$code3 = ''

# write.csv(disagree_rows_for_coder3, file = paste0('/Volumes/AUERBACHLAB/Columbia/MAPS_Language/data/manual_coding/suicide_language/step_one_coding/to_review/disagreement_rows_for_coder3_', Sys.Date(), '.csv'))
```


```{r}
stage2_cols = c(
  'suicide_related', 'timing',
  "first_si_passive", "first_si_active", "first_nssi_thought", "first_nssi_behav", 
  "first_si_absence", "first_victim", "first_sb", "first_lifehate", 
  "first_helpseek", "first_reason_living", "second_support", "second_victim", 
  "second_si", "second_sb", "second_nssi", "third_support", "third_victim", 
  "third_si", "third_sb", "third_nssi", "jokes_hyperbole", "gaming", 
  "lethal_means", "resources", "maps", "celeb", "media", "art", "unclear", "other"
)
```

# Pull in coder3 ratings to break ties

```{r}
# Step 1: Read and process coder3_ratings
coder3_ratings <- read_csv("../../../data/manual_coding/suicide_language/step_one_coding/to_review/disagreement_rows_for_coder3_2025-05-06.csv") %>%
  select(subjectID, tm_message_start, tm_message_end, id_app, text_clean, code3) %>%
  mutate(
    tm_message_startj = mdy_hm(tm_message_start, tz = "UTC"),
    tm_message_endj   = mdy_hm(tm_message_end, tz = "UTC")
  ) %>%
  dplyr::select(-tm_message_start, -tm_message_end)

# Step 2: Process final_codings (coalesced), keeping full timestamps
final_codings <- coalesced %>%
  ungroup() %>%
  mutate(
    tm_message_startj = floor_date(ymd_hms(tm_message_start, tz = "UTC"), unit = "minute"),
    tm_message_endj   = floor_date(ymd_hms(tm_message_end, tz = "UTC"), unit = "minute")
  )

# Step 3: Join on truncated timestamps
final_codings <- left_join(final_codings,
                           coder3_ratings,
                           by = c("subjectID", "tm_message_startj", "tm_message_endj", "id_app", "text_clean"))



sum(!is.na(final_codings$code3))

final_codings = final_codings %>%
  mutate(suicide_related = 
           case_when(code1 == code2 ~ code1,
                     code1 != code2 & !is.na(code3) ~ code3,
                     code1 != code2 & is.na(code3) ~ 1
           ))

c = dplyr::filter(final_codings, code1!=code2)

final_codings = final_codings %>%
  dplyr::select(-contains('code'), -tm_message_startj, -tm_message_endj)


write.csv(tmp_final_coding, file = '../../../data/manual_coding/suicide_language/step_one_coding/coded_reconverted_csvs/final/final_codings.csv', row.names = FALSE)
```